<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tetrisnake</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 10px;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(20, 20px);
      grid-template-rows: repeat(20, 20px);
      gap: 1px;
      background: #444;
      touch-action: manipulation;
    }
    .cell {
      width: 20px;
      height: 20px;
      background: #222;
    }
    .active {
      background: #0f0;
    }
    .fixed {
      background: #09f;
    }
    #timer {
      margin: 10px;
      font-size: 1.2em;
    }
  </style>
</head>
<body>
  <h1>Tetrisnake</h1>
  <div id="timer">Připraven...</div>
  <div id="game"></div>

  <script>
    const game = document.getElementById('game');
    const timer = document.getElementById('timer');
    const gridSize = 20;
    const grid = [];

    let currentPiece = null;
    let lockTime = null;
    let moveDirection = null;
    let moveInterval = null;
    let newPieceTimeout = null;
    let touchStart = null;

    const shapes = {
      I: [[1,1,1,1]],
      O: [[1,1],[1,1]],
      T: [[0,1,0],[1,1,1]],
      L: [[1,0],[1,0],[1,1]],
      J: [[0,1],[0,1],[1,1]],
      S: [[0,1,1],[1,1,0]],
      Z: [[1,1,0],[0,1,1]]
    };

    function createGrid() {
      for (let y = 0; y < gridSize; y++) {
        grid[y] = [];
        for (let x = 0; x < gridSize; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          game.appendChild(cell);
          grid[y][x] = cell;
        }
      }
    }

    function drawPiece(piece, className) {
      piece.shape.forEach((row, dy) => {
        row.forEach((val, dx) => {
          if (val) {
            const x = piece.x + dx;
            const y = piece.y + dy;
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
              grid[y][x].classList.add(className);
            }
          }
        });
      });
    }

    function clearGrid(className) {
      for (let row of grid) {
        for (let cell of row) {
          cell.classList.remove(className);
        }
      }
    }

    function collides(piece) {
      return piece.shape.some((row, dy) =>
        row.some((val, dx) => {
          if (!val) return false;
          const x = piece.x + dx;
          const y = piece.y + dy;
          return x < 0 || x >= gridSize || y < 0 || y >= gridSize || grid[y][x].classList.contains('fixed');
        })
      );
    }

    function tryMovePiece(dx, dy) {
      if (!currentPiece) return false;
      clearGrid('active');
      currentPiece.x += dx;
      currentPiece.y += dy;
      if (collides(currentPiece)) {
        currentPiece.x -= dx;
        currentPiece.y -= dy;
        if (!lockTime) {
          startLockCountdown();
        }
        drawPiece(currentPiece, 'active');
        return false;
      }
      drawPiece(currentPiece, 'active');
      return true;
    }

    function startAutoMove(dx, dy) {
      moveDirection = [dx, dy];
      if (moveInterval) clearInterval(moveInterval);
      moveInterval = setInterval(() => {
        const moved = tryMovePiece(dx, dy);
        if (!moved) clearInterval(moveInterval);
      }, 1000);
    }

    function startLockCountdown() {
      lockTime = Date.now();
      const lockInterval = setInterval(() => {
        const elapsed = (Date.now() - lockTime) / 1000;
        updateTimerDisplay('Ukotvení za: ' + (3 - elapsed).toFixed(1) + ' s');
        if (elapsed >= 3) {
          clearInterval(lockInterval);
          fixPiece();
          startNewPieceCountdown();
        }
      }, 100);
    }

    function fixPiece() {
      clearGrid('active');
      drawPiece(currentPiece, 'fixed');
    }

    function startNewPieceCountdown() {
      let seconds = 3;
      updateTimerDisplay('Nový objekt za: ' + seconds + ' s');
      newPieceTimeout = setInterval(() => {
        seconds -= 0.1;
        if (seconds <= 0) {
          clearInterval(newPieceTimeout);
          spawnPiece();
        } else {
          updateTimerDisplay('Nový objekt za: ' + seconds.toFixed(1) + ' s');
        }
      }, 100);
    }

    function updateTimerDisplay(text) {
      timer.textContent = text;
    }

    function spawnPiece() {
      if (moveInterval) clearInterval(moveInterval);
      const keys = Object.keys(shapes);
      const shape = shapes[keys[Math.floor(Math.random() * keys.length)]];
      currentPiece = { x: 10, y: 10, shape: shape };
      if (collides(currentPiece)) {
        alert("Konec hry!");
        location.reload();
      }
      drawPiece(currentPiece, 'active');
      lockTime = null;
      updateTimerDisplay('');
    }

    function rotatePiece() {
      if (!currentPiece) return;
      clearGrid('active');
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const oldShape = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collides(currentPiece)) {
        currentPiece.shape = oldShape;
      }
      drawPiece(currentPiece, 'active');
    }

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') startAutoMove(-1, 0);
      if (e.key === 'ArrowRight') startAutoMove(1, 0);
      if (e.key === 'ArrowUp') startAutoMove(0, -1);
      if (e.key === 'ArrowDown') startAutoMove(0, 1);
      if (e.key === 'x') rotatePiece();
    });

    game.addEventListener('mousedown', e => {
      const rect = game.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const dx = e.clientX - centerX;
      const dy = e.clientY - centerY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0) startAutoMove(1, 0);
        else startAutoMove(-1, 0);
      } else {
        if (dy > 0) startAutoMove(0, 1);
        else startAutoMove(0, -1);
      }
    });

    game.addEventListener('dblclick', rotatePiece);

    game.addEventListener('touchstart', e => {
      touchStart = e.touches[0];
    });

    game.addEventListener('touchend', e => {
      if (!touchStart) return;
      let dx = e.changedTouches[0].clientX - touchStart.clientX;
      let dy = e.changedTouches[0].clientY - touchStart.clientY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 10) startAutoMove(1, 0);
        if (dx < -10) startAutoMove(-1, 0);
      } else {
        if (dy > 10) startAutoMove(0, 1);
        if (dy < -10) startAutoMove(0, -1);
      }
      touchStart = null;
    });

    game.addEventListener('touchstart', e => {
      if (e.touches.length === 2) rotatePiece();
    });

    createGrid();
    spawnPiece();
  </script>
</body>
</html>
